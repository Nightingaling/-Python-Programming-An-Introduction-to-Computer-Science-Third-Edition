# Chapter 13: Algorithm Design and Recursion

## Review Questions
True/False

    1. Linear search requires a number of steps proportional to the size of the list being searched.
    2. The Python operator in performs a binary search.
    3. Binary search is an n log n algorithm.
    4. The number of times n can be divided by 2 is exp(n).
    5. All proper recursive definitions must have exactly one non-recursive base case.
    6. A sequence can be viewed as a recursive data collection.
    7. A word of length n has n! anagrams.
    8. Loops are more general than recursion.
    9. Merge sort is an example of an n log n algorithm.
    10. Exponential algorithms are generally considered intractable.

</br>

## Multiple Choice
### 1. Which algorithm requires time directly proportional to the size of the input?
    a) linear search b) binary search
    c) merge sort d) selection sort
    
### 2. Approximately how many iterations will binary search need to find a value in a list of 512 items?
    a) 512 b) 256 c) 9 d) 3
    
### 3. Recursions on sequences often use this as a base case:
    a) 0 b) 1 c) an empty sequence d) None
    
### 4. An infinite recursion will result in
    a) a program that "hangs"
    b) a broken computer
    c) a reboot
    d) a run-time exception
    
### 5. The recursive Fibonacci function is inefficient because
    a) it does many repeated computations
    b) recursion is inherently inefficient compared to iteration
    c) calculating Fibonacci numbers is intractable
    d) fibbing is morally wrong
    
### 6. Which is a quadratic time algorithm?
    a) linear search b) binary search
    c) Tower of Hanoi d) selection sort
    
### 7. The process of combining two sorted sequences is called
    a) sorting b) shuffling c) dovetailing d) merging
    
### 8. Recursion is related to the mathematical technique called
    a) looping b) sequencing c) induction d) contradiction
    
### 9. How many steps would be needed to solve the Tower of Hanoi for a tower of size 5?
    a) 5 b) 10 c) 25 d) 31

### 10. Which of the following is not true of the halting problem?
    a) It was studied by Alan Turing.
    b) It is harder than intractable.
    c) Someday a clever algorithm may be found to solve it.
    d) It involves a program that analyzes other programs.

</br>

## Discussion
### 1. Place these algorithm classes in order from fastest to slowest: nlog(n), n, n<sup>2</sup>, log(n), 2<sup>n</sup>

</br>

### 2. In your own words, explain the two rules that a proper recursive definition or function must follow.

</br>

### 3. What is the exact result of anagram("foo")?

</br>

### 4. Trace recPower(3,6) and figure out exactly how many multiplications it performs.

</br>

### 5. Why are divide-and-conquer algorithms often very efficient?

</br>

## Programming Exercises
PAGE 513
