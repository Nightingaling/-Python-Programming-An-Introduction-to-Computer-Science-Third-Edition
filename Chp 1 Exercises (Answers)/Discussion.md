### **1. Compare and Contrast**  
**a) Hardware vs. Software**  
- **Hardware**: Physical components (e.g., CPU, keyboard).  
- **Software**: Instructions/programs (e.g., OS, apps).  
- **Contrast**: Hardware is tangible; software is intangible.  
- **Similarity**: Both are essential for a functioning computer.  

**b) Algorithm vs. Program**  
- **Algorithm**: Abstract step-by-step solution (e.g., a recipe).  
- **Program**: Concrete implementation of an algorithm in code.  
- **Contrast**: Algorithms are general; programs are specific to a language.  

**c) Programming Language vs. Natural Language**  
- **Programming Language**: Strict syntax, unambiguous (e.g., Python).  
- **Natural Language**: Flexible, context-dependent (e.g., English).  
- **Contrast**: Programming languages are machine-readable; natural languages are human-centric.  

**d) High-Level Language vs. Machine Language**  
- **High-Level**: Human-readable (e.g., Python, requires translation).  
- **Machine Language**: Binary code executed directly by the CPU.  
- **Contrast**: High-level is portable; machine language is hardware-specific.  

**e) Interpreter vs. Compiler**  
- **Interpreter**: Translates/executes line-by-line (e.g., Python).  
- **Compiler**: Translates entire code upfront (e.g., C++).  
- **Contrast**: Interpreters are slower but flexible; compilers are faster but require pre-processing.  

**f) Syntax vs. Semantics**  
- **Syntax**: Rules for writing valid code (e.g., correct punctuation).  
- **Semantics**: Meaning of code (e.g., logical correctness).  
- **Contrast**: Syntax errors prevent execution; semantic errors produce wrong results.  

---

### **2. Five Basic Functional Units of a Computer**  
1. **Input Unit**: Collects data (e.g., keyboard, mouse).  
2. **Output Unit**: Displays results (e.g., monitor, printer).  
3. **Memory Unit (RAM)**: Temporarily stores data/instructions.  
4. **Arithmetic Logic Unit (ALU)**: Performs calculations/logic operations.  
5. **Control Unit (CU)**: Coordinates operations (e.g., fetches instructions).  

**Role**: Together, they enable input → processing → output.  

---

### **3. Algorithm for Making a PB&J Sandwich**  
1. **Gather**: Bread, peanut butter, jelly, knife, plate.  
2. **Place** two bread slices on the plate.  
3. **Open** peanut butter jar. **Spread** peanut butter on one slice. **Close** jar.  
4. **Open** jelly jar. **Spread** jelly on the other slice. **Close** jar.  
5. **Press** slices together (spread sides inward).  
6. **Cut** diagonally (optional). **Serve**.  

---

### **4. Issues with Approximate Number Storage**  
**Examples**:  
- **Financial Systems**: Rounding errors in compound interest calculations.  
- **Engineering**: Incorrect stress predictions due to tiny inaccuracies.  
- **Chaotic Systems**: Weather models where small errors lead to drastically wrong forecasts.  

**Explanation**: Chaotic systems amplify initial errors, making approximations risky.  

---

### **5. Tracing the Chaotic Program with Input 0.15**  
Assume the function \( x_{n+1} = 3.9 \cdot x_n \cdot (1 - x_n) \):  
- **Input**: \( x_0 = 0.15 \)  
- **Output Sequence**:  
  1. \( x_1 ≈ 0.49725 \)  
  2. \( x_2 ≈ 0.9747 \)  
  3. \( x_3 ≈ 0.0956 \)  
  4. \( x_4 ≈ 0.335 \)  
  5. \( x_5 ≈ 0.870 \)  
  6. ... (values oscillate chaotically).  

**Conclusion**: Demonstrates sensitivity to initial conditions, a hallmark of chaos.  

--- 
